# üöó –ü–æ–≤–Ω–∏–π –ü–ª–∞–Ω –†–æ–∑—Ä–æ–±–∫–∏ –ü—Ä–æ—Ñ–µ—Å—ñ–π–Ω–æ–≥–æ –ü–ó –¥–ª—è –î—ñ–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ –ê–≤—Ç–æ–º–æ–±—ñ–ª—ñ–≤
# Complete Guide for Professional Automotive Diagnostic Software Development

[![Automotive Diagnostic Software](https://img.shields.io/badge/Industry-Automotive-blue)]()
[![AI Agents](https://img.shields.io/badge/Powered%20By-AI%20Agents-green)]()
[![Android](https://img.shields.io/badge/Platform-Android-brightgreen)]()

---

## üìã –ó–º—ñ—Å—Ç / Table of Contents

1. [–í—Å—Ç—É–ø / Introduction](#–≤—Å—Ç—É–ø--introduction)
2. [–ê—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∞ –°–∏—Å—Ç–µ–º–∏ / System Architecture](#–∞—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∞-—Å–∏—Å—Ç–µ–º–∏--system-architecture)
3. [–ü–æ–µ—Ç–∞–ø–Ω–∏–π –ü–ª–∞–Ω –†–æ–∑—Ä–æ–±–∫–∏ / Step-by-Step Development Plan](#–ø–æ–µ—Ç–∞–ø–Ω–∏–π-–ø–ª–∞–Ω-—Ä–æ–∑—Ä–æ–±–∫–∏--step-by-step-development-plan)
4. [–†–æ–±–æ—Ç–∞ –∑ AI –ê–≥–µ–Ω—Ç–∞–º–∏ / Working with AI Agents](#—Ä–æ–±–æ—Ç–∞-–∑-ai-–∞–≥–µ–Ω—Ç–∞–º–∏--working-with-ai-agents)
5. [–Ü–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—è –ê–ø–∞—Ä–∞—Ç–Ω–æ–≥–æ –ó–∞–±–µ–∑–ø–µ—á–µ–Ω–Ω—è / Hardware Integration](#—ñ–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—è-–∞–ø–∞—Ä–∞—Ç–Ω–æ–≥–æ-–∑–∞–±–µ–∑–ø–µ—á–µ–Ω–Ω—è--hardware-integration)
6. [–¢–µ—Å—Ç—É–≤–∞–Ω–Ω—è —Ç–∞ –ö–æ–Ω—Ç—Ä–æ–ª—å –Ø–∫–æ—Å—Ç—ñ / Testing and Quality Control](#—Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—è-—Ç–∞-–∫–æ–Ω—Ç—Ä–æ–ª—å-—è–∫–æ—Å—Ç—ñ--testing-and-quality-control)
7. [–°–∏—Å—Ç–µ–º–∞ –û–Ω–æ–≤–ª–µ–Ω—å / Update System](#—Å–∏—Å—Ç–µ–º–∞-–æ–Ω–æ–≤–ª–µ–Ω—å--update-system)
8. [–ë—ñ–∑–Ω–µ—Å-–ú–æ–¥–µ–ª—å / Business Model](#–±—ñ–∑–Ω–µ—Å-–º–æ–¥–µ–ª—å--business-model)

---

## üéØ –í—Å—Ç—É–ø / Introduction

### –ú–µ—Ç–∞ –ü—Ä–æ—î–∫—Ç—É / Project Goal

–°—Ç–≤–æ—Ä–µ–Ω–Ω—è –ø—Ä–æ—Ñ–µ—Å—ñ–π–Ω–æ–≥–æ –º—É–ª—å—Ç–∏–º–∞—Ä–æ—á–Ω–æ–≥–æ –∞–≤—Ç–æ—Å–∫–∞–Ω–µ—Ä–∞ –Ω–æ–≤–æ–≥–æ –ø–æ–∫–æ–ª—ñ–Ω–Ω—è –¥–ª—è Android-–ø–ª–∞–Ω—à–µ—Ç—ñ–≤, —è–∫–∏–π:
- ‚úÖ –ü–µ—Ä–µ–≤–∏—â—É—î —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª—å–Ω—ñ—Å—Ç—å Launch X431 PRO/PRO5
- ‚úÖ –ú–∞—î –ø–æ–≤–Ω—É –∞–≤—Ç–æ–Ω–æ–º–Ω—ñ—Å—Ç—å —Ç–∞ –≤–ª–∞—Å–Ω–µ –ü–ó
- ‚úÖ –ü—ñ–¥—Ç—Ä–∏–º—É—î –≤–ª–∞—Å–Ω—ñ –æ–Ω–æ–≤–ª–µ–Ω–Ω—è –±–µ–∑ –∑–∞–ª–µ–∂–Ω–æ—Å—Ç—ñ –≤—ñ–¥ –≤–∏—Ä–æ–±–Ω–∏–∫—ñ–≤
- ‚úÖ –û—Ä—ñ—î–Ω—Ç–æ–≤–∞–Ω–∏–π –Ω–∞ –ø—Ä–æ—Ñ–µ—Å—ñ–π–Ω–∏—Ö –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤
- ‚úÖ –†–æ–∑—Ä–æ–±–ª—è—î—Ç—å—Å—è –∑ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è–º AI-–∞–≥–µ–Ω—Ç—ñ–≤

**Creating a next-generation professional multi-brand auto scanner for Android tablets that:**
- ‚úÖ Exceeds Launch X431 PRO/PRO5 functionality
- ‚úÖ Has complete autonomy and proprietary software
- ‚úÖ Supports independent updates without manufacturer dependency
- ‚úÖ Targets professional users
- ‚úÖ Developed using AI agents

---

## üèóÔ∏è –ê—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∞ –°–∏—Å—Ç–µ–º–∏ / System Architecture

### 1. –¢—Ä—å–æ—Ö—Ä—ñ–≤–Ω–µ–≤–∞ –ê—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∞ / Three-Tier Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    PRESENTATION LAYER                        ‚îÇ
‚îÇ              (Android UI - Kotlin/Java)                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                    BUSINESS LOGIC LAYER                      ‚îÇ
‚îÇ         (Protocol Handlers, Data Processing, AI)             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                    DATA ACCESS LAYER                         ‚îÇ
‚îÇ        (Hardware Interface, Database, Cloud Sync)            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 2. –û—Å–Ω–æ–≤–Ω—ñ –ö–æ–º–ø–æ–Ω–µ–Ω—Ç–∏ / Core Components

#### A. –ü—Ä–µ–∑–µ–Ω—Ç–∞—Ü—ñ–π–Ω–∏–π –†—ñ–≤–µ–Ω—å / Presentation Layer
- **Android Application (Kotlin/Jetpack Compose)**
  - Dashboard –∑ real-time –¥–∞–Ω–∏–º–∏
  - –ú–æ–¥—É–ª—å –¥—ñ–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ –ø–æ –º–∞—Ä–∫–∞—Ö
  - –Ü–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∫–æ–¥—É–≤–∞–Ω–Ω—è/–ø—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—è
  - –°–∏—Å—Ç–µ–º–∞ –∑–≤—ñ—Ç—ñ–≤ —Ç–∞ –ª–æ–≥—ñ–≤
  - –ë–∞–≥–∞—Ç–æ–º–æ–≤–Ω–∏–π —ñ–Ω—Ç–µ—Ä—Ñ–µ–π—Å (UA/EN/RU/DE/FR)

#### B. –ë—ñ–∑–Ω–µ—Å-–õ–æ–≥—ñ–∫–∞ / Business Logic
- **Protocol Handlers**
  - OBD-II (ISO 9141, ISO 14230, ISO 15765)
  - CAN Bus (ISO 11898)
  - DoIP (Diagnostics over IP)
  - UDS (Unified Diagnostic Services - ISO 14229)
  - Manufacturer-specific protocols (VAG, BMW, Mercedes, etc.)

- **AI-Powered Features**
  - –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–∞ –¥—ñ–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –Ω–µ—Å–ø—Ä–∞–≤–Ω–æ—Å—Ç–µ–π
  - –Ü–Ω—Ç–µ–ª–µ–∫—Ç—É–∞–ª—å–Ω–∞ —ñ–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü—ñ—è –∫–æ–¥—ñ–≤ –ø–æ–º–∏–ª–æ–∫
  - –ü—Ä–æ–≥–Ω–æ–∑—É–≤–∞–Ω–Ω—è –ø–æ–ª–æ–º–æ–∫
  - –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü—ñ—ó –ø–æ —Ä–µ–º–æ–Ω—Ç—É

#### C. –†—ñ–≤–µ–Ω—å –î–∞–Ω–∏—Ö / Data Layer
- **Local Database (SQLite/Room)**
  - –ë–∞–∑–∞ –∫–æ–¥—ñ–≤ –ø–æ–º–∏–ª–æ–∫ (50,000+ codes)
  - –î—ñ–∞–≥–Ω–æ—Å—Ç–∏—á–Ω—ñ –ø—Ä–æ—Ü–µ–¥—É—Ä–∏
  - –Ü—Å—Ç–æ—Ä—ñ—è —Å–∫–∞–Ω—É–≤–∞–Ω—å
  - –ö–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–Ω–∏—Ö –∑–∞—Å–æ–±—ñ–≤

- **Cloud Integration**
  - –°–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—è –¥–∞–Ω–∏—Ö
  - –°–∏—Å—Ç–µ–º–∞ –æ–Ω–æ–≤–ª–µ–Ω—å
  - –¢–µ–ª–µ–º–µ—Ç—Ä—ñ—è —Ç–∞ –∞–Ω–∞–ª—ñ—Ç–∏–∫–∞
  - Backup —Ç–∞ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è

---

## üìù –ü–æ–µ—Ç–∞–ø–Ω–∏–π –ü–ª–∞–Ω –†–æ–∑—Ä–æ–±–∫–∏ / Step-by-Step Development Plan

## –§–ê–ó–ê 1: –ü–Ü–î–ì–û–¢–û–í–ö–ê –¢–ê –î–û–°–õ–Ü–î–ñ–ï–ù–ù–Ø (4-6 —Ç–∏–∂–Ω—ñ–≤)

### –¢–∏–∂–¥–µ–Ω—å 1-2: –ê–Ω–∞–ª—ñ–∑ —Ç–∞ –ü–ª–∞–Ω—É–≤–∞–Ω–Ω—è

#### –ó–∞–≤–¥–∞–Ω–Ω—è 1.1: –ê–Ω–∞–ª—ñ–∑ –ö–æ–Ω–∫—É—Ä–µ–Ω—Ç—ñ–≤
**AI Agent Role:** Research Agent

**–ü—Ä–æ–º–ø—Ç –¥–ª—è AI Agent:**
```
Analyze the following automotive diagnostic tools and create a comprehensive feature comparison:
- Launch X431 PRO/PRO5
- Autel MaxiSys Elite
- Snap-on MODIS
- Bosch KTS

Focus on:
1. Supported vehicle protocols
2. Diagnostic capabilities
3. Special functions (coding, programming, adaptations)
4. Hardware specifications
5. Software architecture patterns
6. Update mechanisms
7. Price points and licensing models

Output: Detailed markdown table with feature matrix
```

#### –ó–∞–≤–¥–∞–Ω–Ω—è 1.2: –í–∏–∑–Ω–∞—á–µ–Ω–Ω—è MVP Features
**–ú—ñ–Ω—ñ–º–∞–ª—å–Ω–æ –ù–µ–æ–±—Ö—ñ–¥–Ω–∏–π –§—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª:**
- ‚úÖ –ß–∏—Ç–∞–Ω–Ω—è/–æ—á–∏—â–µ–Ω–Ω—è –∫–æ–¥—ñ–≤ –ø–æ–º–∏–ª–æ–∫ (DTC)
- ‚úÖ Live Data –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ (PID)
- ‚úÖ Freeze Frame –¥–∞–Ω–Ω—ñ
- ‚úÖ –ë–∞–∑–æ–≤—ñ —Ç–µ—Å—Ç–∏ –∞–∫—Ç—É–∞—Ç–æ—Ä—ñ–≤
- ‚úÖ 20+ –ø–æ–ø—É–ª—è—Ä–Ω–∏—Ö –º–∞—Ä–æ–∫ –∞–≤—Ç–æ
- ‚úÖ OBD-II –ø—Ä–æ—Ç–æ–∫–æ–ª–∏
- ‚úÖ –£–∫—Ä–∞—ó–Ω—Å—å–∫–∞/–ê–Ω–≥–ª—ñ–π—Å—å–∫–∞ –º–æ–≤–∏

### –¢–∏–∂–¥–µ–Ω—å 3-4: –¢–µ—Ö–Ω—ñ—á–Ω–µ –ü—Ä–æ–µ–∫—Ç—É–≤–∞–Ω–Ω—è

#### –ó–∞–≤–¥–∞–Ω–Ω—è 1.3: –í–∏–±—ñ—Ä –¢–µ—Ö–Ω–æ–ª–æ–≥—ñ—á–Ω–æ–≥–æ –°—Ç–µ–∫—É
**–†–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω–∏–π Stack:**

**Frontend (Android):**
```kotlin
// build.gradle.kts
dependencies {
    // Jetpack Compose –¥–ª—è UI
    implementation("androidx.compose.ui:ui:1.5.4")
    implementation("androidx.compose.material3:material3:1.1.2")
    
    // Navigation
    implementation("androidx.navigation:navigation-compose:2.7.5")
    
    // ViewModel
    implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.6.2")
    
    // –ö–æ—Ä—É—Ç–∏–Ω–∏ –¥–ª—è –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ—Å—Ç—ñ
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3")
    
    // Bluetooth/USB –∫–æ–º—É–Ω—ñ–∫–∞—Ü—ñ—è
    implementation("com.github.mik3y:usb-serial-for-android:3.6.0")
    
    // Database
    implementation("androidx.room:room-runtime:2.6.0")
    implementation("androidx.room:room-ktx:2.6.0")
    
    // Dependency Injection
    implementation("com.google.dagger:hilt-android:2.48")
}
```

**Backend Services:**
```python
# requirements.txt
fastapi==0.104.1          # REST API
uvicorn==0.24.0          # ASGI Server
sqlalchemy==2.0.23       # ORM
alembic==1.12.1          # Database migrations
redis==5.0.1             # Caching
celery==5.3.4            # Task queue
pydantic==2.5.0          # Data validation
python-j1939==2.0.0      # Vehicle protocols
can==4.0.0               # CAN Bus support
```

#### –ó–∞–≤–¥–∞–Ω–Ω—è 1.4: –î–∏–∑–∞–π–Ω Database Schema
**AI Agent Role:** Database Architect

**–ü—Ä–æ–º–ø—Ç –¥–ª—è AI Agent:**
```
Design a comprehensive database schema for an automotive diagnostic application with the following requirements:

Entities needed:
1. Vehicle Database (make, model, year, VIN decoder)
2. Diagnostic Trouble Codes (DTC) - 50,000+ codes
3. Parameters/PIDs with formulas
4. Diagnostic Procedures
5. User Sessions and History
6. Vehicle Profiles
7. Software Updates metadata

Requirements:
- Optimized for mobile (SQLite)
- Support for offline operation
- Efficient search and filtering
- Version control for data updates
- Multi-language support

Output: SQL schema with indexes, relationships, and sample queries
```

---

## –§–ê–ó–ê 2: –ü–†–û–¢–û–¢–ò–ü–£–í–ê–ù–ù–Ø (6-8 —Ç–∏–∂–Ω—ñ–≤)

### –¢–∏–∂–¥–µ–Ω—å 5-8: –†–æ–∑—Ä–æ–±–∫–∞ Core –§—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª—É

#### –ó–∞–≤–¥–∞–Ω–Ω—è 2.1: –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ü—Ä–æ—î–∫—Ç—É
**AI Agent Role:** DevOps Agent

**–Ü–Ω—Å—Ç—Ä—É–∫—Ü—ñ—è –¥–ª—è GitHub Copilot:**
```
Create Android project structure for automotive diagnostic app:

/AutoDiagPro
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ java/com/autodiag/
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ui/              # Jetpack Compose UI
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ domain/          # Business logic
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ data/            # Data layer
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ local/       # Room database
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ remote/      # API calls
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ repository/  # Repository pattern
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hardware/        # Hardware interfaces
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ obd/         # OBD protocols
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ can/         # CAN Bus
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ usb/         # USB/Bluetooth
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ utils/           # Utilities
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ res/                 # Resources
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ test/                    # Unit tests
‚îú‚îÄ‚îÄ backend/                          # Optional cloud backend
‚îÇ   ‚îú‚îÄ‚îÄ api/                         # FastAPI services
‚îÇ   ‚îú‚îÄ‚îÄ models/                      # Data models
‚îÇ   ‚îî‚îÄ‚îÄ services/                    # Business services
‚îî‚îÄ‚îÄ docs/                            # Documentation

Generate:
1. build.gradle.kts with all dependencies
2. Hilt/Dagger setup
3. Room database configuration
4. Navigation graph
5. Base Activity and ViewModels
```

#### –ó–∞–≤–¥–∞–Ω–Ω—è 2.2: –Ü–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü—ñ—è OBD-II –ö–æ–º—É–Ω—ñ–∫–∞—Ü—ñ—ó
**AI Agent Role:** Protocol Implementation Agent

**–î–µ—Ç–∞–ª—å–Ω–∏–π –ø—Ä–æ–º–ø—Ç –¥–ª—è Claude/GPT-4:**
```
Implement OBD-II communication layer for Android using Kotlin:

Requirements:
1. Support for ELM327-based adapters (Bluetooth/WiFi/USB)
2. Protocol auto-detection (ISO 9141-2, ISO 14230-4, ISO 15765-4, etc.)
3. AT command handling
4. PID request/response parsing
5. DTC reading and clearing
6. Error handling and retry logic
7. Async operations with Kotlin coroutines

Create these classes:
- OBDProtocol enum
- ELM327Connector class
- OBDCommand sealed class
- OBDResponse data class
- OBDRepository interface
- ConnectionManager

Include:
- Complete implementation
- Unit tests
- Usage examples
- Documentation comments
```

**–ü—Ä–∏–∫–ª–∞–¥ –ö–æ–¥—É (Generate by AI):**
```kotlin
// OBDProtocol.kt
sealed class OBDProtocol {
    abstract val identifier: String
    abstract val baudRate: Int
    
    object ISO9141_2 : OBDProtocol() {
        override val identifier = "ISO 9141-2"
        override val baudRate = 10400
    }
    
    object ISO14230_4 : OBDProtocol() {
        override val identifier = "ISO 14230-4 (KWP2000)"
        override val baudRate = 10400
    }
    
    object ISO15765_4_CAN : OBDProtocol() {
        override val identifier = "ISO 15765-4 (CAN)"
        override val baudRate = 500000
    }
}

// ELM327Connector.kt
class ELM327Connector(
    private val ioStream: IOStream,
    private val dispatcher: CoroutineDispatcher = Dispatchers.IO
) {
    private var currentProtocol: OBDProtocol? = null
    
    suspend fun connect(): Result<Boolean> = withContext(dispatcher) {
        try {
            // Reset adapter
            sendCommand("ATZ").getOrThrow()
            delay(1000)
            
            // Turn off echo
            sendCommand("ATE0").getOrThrow()
            
            // Auto protocol detection
            sendCommand("ATSP0").getOrThrow()
            
            // Verify connection with 0100 PID
            val response = sendCommand("0100").getOrThrow()
            
            Result.success(response.isNotEmpty())
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun readDTCs(): Result<List<DTC>> = withContext(dispatcher) {
        try {
            val response = sendCommand("03").getOrThrow()
            val dtcs = parseDTCs(response)
            Result.success(dtcs)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    private suspend fun sendCommand(command: String): Result<String> {
        return try {
            ioStream.write("$command\r")
            val response = ioStream.readUntil(">", timeout = 5000)
            Result.success(response)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

### –¢–∏–∂–¥–µ–Ω—å 9-12: UI/UX –†–æ–∑—Ä–æ–±–∫–∞

#### –ó–∞–≤–¥–∞–Ω–Ω—è 2.3: –î–∏–∑–∞–π–Ω UI/UX
**AI Agent Role:** UI/UX Designer Agent

**–ü—Ä–æ–º–ø—Ç –¥–ª—è Figma AI / MidJourney:**
```
Design modern professional automotive diagnostic app interface:

Screens needed:
1. Dashboard - Live vehicle stats (RPM, Speed, Temp, Voltage)
2. DTC Scanner - List of error codes with severity indicators
3. Live Data - Real-time PID monitoring with graphs
4. Vehicle Selection - Brand/Model/Year picker
5. Special Functions - Coding, Adaptations, Tests
6. Reports - PDF generation with charts
7. Settings - Language, Units, Connection

Style requirements:
- Dark theme optimized for garage environment
- High contrast for outdoor visibility
- Large touch targets for gloved hands
- Material Design 3
- Colors: Dark blue (#0D1B2A), Electric blue (#00D9FF), Warning red (#FF6B6B)
- Icons: Automotive-themed, clear, professional

Output: Figma file with all screens and components
```

#### –ó–∞–≤–¥–∞–Ω–Ω—è 2.4: –Ü–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü—ñ—è UI –∑ Jetpack Compose
**AI Agent Role:** Frontend Developer Agent

**–ü—Ä–æ–º–ø—Ç –¥–ª—è Copilot:**
```kotlin
// Generate Jetpack Compose screens for automotive diagnostic app

// 1. Dashboard Screen with live data
@Composable
fun DashboardScreen(viewModel: DashboardViewModel) {
    // Show 4 main gauges: RPM, Speed, Coolant Temp, Battery Voltage
    // Include status indicators for engine, transmission, ABS, airbag
    // Bottom section: Quick actions (Scan, Clear DTC, Live Data)
}

// 2. DTC Scanner Screen
@Composable
fun DTCScreen(viewModel: DTCViewModel) {
    // Top: Scan button with progress indicator
    // List of DTCs with:
    //   - Code (P0420)
    //   - Description
    //   - Status (Confirmed/Pending)
    //   - Severity indicator
    // Actions: Clear codes, View details, Generate report
}

// 3. Live Data Screen with real-time graphs
@Composable
fun LiveDataScreen(viewModel: LiveDataViewModel) {
    // Top: Auto-refresh toggle, refresh rate selector
    // Scrollable list of PIDs with current values
    // Tap PID to show graph
    // Support multiple simultaneous graphs
}

Requirements:
- Use Material 3 components
- Dark theme
- Proper state management with ViewModel
- Loading/Error states
- Smooth animations
- Accessibility support
```

---

## –§–ê–ó–ê 3: –†–û–ó–®–ò–†–ï–ù–ò–ô –§–£–ù–ö–¶–Ü–û–ù–ê–õ (8-10 —Ç–∏–∂–Ω—ñ–≤)

### –¢–∏–∂–¥–µ–Ω—å 13-16: Manufacturer-Specific Features

#### –ó–∞–≤–¥–∞–Ω–Ω—è 3.1: –Ü–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü—ñ—è VAG Protocol
**AI Agent Role:** Automotive Protocol Specialist

**–ü—Ä–æ–º–ø—Ç –¥–ª—è AI Agent:**
```
Implement Volkswagen Audi Group (VAG) diagnostic protocol:

Requirements:
1. KWP2000 protocol support
2. Control module identification
3. Coding/Long coding
4. Adaptations
5. Basic settings
6. Component testing
7. Security access (login codes)

Supported modules:
- Engine (01)
- Transmission (02)
- ABS (03)
- Airbag (15)
- Instrument cluster (17)
- Central convenience (46)

Create:
- VAGProtocol class
- ControlModule data class
- CodingHelper utility
- Sample data for Golf Mk7

Include detailed comments and error handling
```

#### –ó–∞–≤–¥–∞–Ω–Ω—è 3.2: AI-Powered Diagnostics
**AI Agent Role:** Machine Learning Engineer

**–ü—Ä–æ–º–ø—Ç –¥–ª—è AI Agent:**
```
Design AI diagnostic assistant using LangGraph:

Features:
1. Symptom-to-cause analysis
2. DTC interpretation with context
3. Repair recommendations
4. Cost estimation
5. Required tools/parts suggestions
6. Step-by-step repair guides

Implementation:
- Use RAG (Retrieval Augmented Generation)
- Knowledge base: Service manuals, TSBs, common fixes
- Multi-language support
- Offline capability with cached responses

Architecture:
- Vector database for repair knowledge (Chroma/Pinecone)
- LLM for reasoning (GPT-4/Claude-3)
- Local embedding model for offline mode
- Feedback loop for continuous improvement

Provide:
- Python implementation
- Integration with Android app via REST API
- Sample knowledge base
- Evaluation metrics
```

**–ü—Ä–∏–∫–ª–∞–¥ –Ü–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—ó:**
```python
# backend/services/ai_diagnostics.py
from langchain.agents import AgentExecutor, create_react_agent
from langchain.tools import Tool
from langchain_community.vectorstores import Chroma
from langchain_openai import ChatOpenAI, OpenAIEmbeddings

class AutomotiveDiagnosticAgent:
    def __init__(self):
        self.embeddings = OpenAIEmbeddings()
        self.vectorstore = Chroma(
            persist_directory="./knowledge_base",
            embedding_function=self.embeddings
        )
        self.llm = ChatOpenAI(model="gpt-4-turbo-preview", temperature=0)
        
        self.tools = [
            Tool(
                name="DTC_Lookup",
                func=self.lookup_dtc,
                description="Look up diagnostic trouble code details"
            ),
            Tool(
                name="Repair_Procedure",
                func=self.get_repair_procedure,
                description="Get step-by-step repair procedure"
            ),
            Tool(
                name="Parts_Lookup",
                func=self.lookup_parts,
                description="Find required parts and costs"
            )
        ]
        
        self.agent = create_react_agent(self.llm, self.tools, self.prompt_template)
        self.executor = AgentExecutor(agent=self.agent, tools=self.tools)
    
    async def diagnose(self, vehicle_info: dict, dtcs: list, symptoms: str):
        """
        Perform comprehensive diagnostic analysis
        """
        query = f"""
        Vehicle: {vehicle_info['make']} {vehicle_info['model']} {vehicle_info['year']}
        DTCs: {', '.join(dtcs)}
        Symptoms: {symptoms}
        
        Provide:
        1. Root cause analysis
        2. Recommended repairs (prioritized)
        3. Estimated cost and time
        4. Required tools and parts
        5. Difficulty level
        """
        
        result = await self.executor.ainvoke({"input": query})
        return result
    
    def lookup_dtc(self, code: str) -> str:
        """Retrieve DTC information from knowledge base"""
        docs = self.vectorstore.similarity_search(f"DTC {code}", k=3)
        return "\n".join([doc.page_content for doc in docs])
```

### –¢–∏–∂–¥–µ–Ω—å 17-20: Special Functions

#### –ó–∞–≤–¥–∞–Ω–Ω—è 3.3: Coding & Programming
**–ö–æ–º–ø–æ–Ω–µ–Ω—Ç–∏ –¥–ª—è –†–µ–∞–ª—ñ–∑–∞—Ü—ñ—ó:**

1. **ECU Coding**
   - Binary/Hex editors
   - Checksum calculators
   - Backup/Restore functions
   - Template-based coding helper

2. **Component Programming**
   - Key programming
   - Injector coding
   - Throttle body adaptation
   - Module replacement procedures

3. **Immobilizer Functions**
   - Key learning
   - PIN code reading
   - EEPROM programming
   - Transponder operations

**AI Agent –¥–ª—è –ì–µ–Ω–µ—Ä–∞—Ü—ñ—ó –ë–µ–∑–ø–µ—á–Ω–æ–≥–æ –ö–æ–¥—É:**
```
Generate secure coding module for automotive ECU programming:

Safety requirements:
- Mandatory backup before any write operation
- Verification after programming
- Rollback capability
- User confirmation for critical operations
- Logging all changes
- VIN verification

Include:
- Write protection mechanisms
- Timeout handling
- Progress monitoring
- Error recovery procedures
- Audit trail

Provide complete implementation with tests
```

---

## –§–ê–ó–ê 4: –Ü–ù–¢–ï–ì–†–ê–¶–Ü–Ø –¢–ê –¢–ï–°–¢–£–í–ê–ù–ù–Ø (6-8 —Ç–∏–∂–Ω—ñ–≤)

### –¢–∏–∂–¥–µ–Ω—å 21-24: Hardware Integration

#### –ó–∞–≤–¥–∞–Ω–Ω—è 4.1: –†–æ–∑—Ä–æ–±–∫–∞/–í–∏–±—ñ—Ä Hardware Adapter

**–í–∞—Ä—ñ–∞–Ω—Ç 1: –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –ì–æ—Ç–æ–≤–∏—Ö –ê–¥–∞–ø—Ç–µ—Ä—ñ–≤**
```
–†–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω—ñ –∞–¥–∞–ø—Ç–µ—Ä–∏:
1. OBDLink MX+ (Bluetooth, multi-protocol)
2. VINT-TT5 (USB, VAG-specific)
3. Autel VCI (WiFi, professional grade)
4. Custom ESP32-based (DIY option)
```

**–í–∞—Ä—ñ–∞–Ω—Ç 2: –†–æ–∑—Ä–æ–±–∫–∞ –í–ª–∞—Å–Ω–æ–≥–æ –ê–¥–∞–ø—Ç–µ—Ä–∞**

**AI Agent Role:** Hardware Engineer

**–ü—Ä–æ–º–ø—Ç –¥–ª—è AI Agent:**
```
Design custom OBD-II adapter based on ESP32:

Specifications:
- MCU: ESP32-WROVER
- CAN Transceiver: MCP2551
- K-Line Interface: MC33290
- Power: Automotive-grade DC-DC converter
- Connectivity: Bluetooth 5.0, WiFi
- Protection: Reverse polarity, ESD, overvoltage

Deliverables:
1. Schematic diagram
2. PCB layout (KiCad)
3. BOM with suppliers
4. Firmware in C++ (Arduino/ESP-IDF)
5. Communication protocol specification
6. Production cost estimate

Output format: Complete hardware package with documentation
```

#### –ó–∞–≤–¥–∞–Ω–Ω—è 4.2: –¢–µ—Å—Ç—É–≤–∞–Ω–Ω—è –Ω–∞ –†–µ–∞–ª—å–Ω–∏—Ö –ê–≤—Ç–æ–º–æ–±—ñ–ª—è—Ö

**–¢–µ—Å—Ç-–ü–ª–∞–Ω:**

| –ú–∞—Ä–∫–∞ | –ú–æ–¥–µ–ª—å | –†—ñ–∫ | –ü—Ä–æ—Ç–æ–∫–æ–ª | –¢–µ—Å—Ç–∏ |
|-------|--------|-----|----------|-------|
| VW | Golf | 2015-2020 | CAN/KWP2000 | DTC, Live Data, Coding, Adaptations |
| BMW | 3 Series | 2012-2018 | CAN/ENET | DTC, Live Data, Coding, Programming |
| Mercedes | C-Class | 2014-2021 | DoIP | DTC, Live Data, SCN Coding |
| Toyota | Corolla | 2016-2023 | CAN | DTC, Live Data, Service Resets |
| Ford | Focus | 2015-2022 | CAN/MS-CAN | DTC, Live Data, Module Programming |

**AI Agent –¥–ª—è –ì–µ–Ω–µ—Ä–∞—Ü—ñ—ó –¢–µ—Å—Ç-–ö–µ–π—Å—ñ–≤:**
```
Generate comprehensive test cases for automotive diagnostic software:

For each vehicle:
1. Connection test
2. DTC read/clear (all modules)
3. Live data verification (20+ PIDs)
4. Freeze frame retrieval
5. Readiness monitors
6. O2 sensor tests
7. Evap system tests
8. Actuator tests
9. Special functions (if supported)

Include:
- Expected results
- Pass/fail criteria
- Performance benchmarks
- Edge cases
- Error scenarios

Output: Detailed test plan in markdown with automation scripts
```

### –¢–∏–∂–¥–µ–Ω—å 25-28: System Testing & Optimization

#### –ó–∞–≤–¥–∞–Ω–Ω—è 4.3: Performance Testing
```python
# Performance benchmarks to meet:

PERFORMANCE_TARGETS = {
    "app_launch_time": "< 2 seconds",
    "connection_establishment": "< 5 seconds",
    "dtc_scan_all_modules": "< 30 seconds",
    "live_data_refresh_rate": "> 10 Hz",
    "database_query": "< 100ms",
    "ui_frame_rate": "> 60 FPS",
    "memory_usage": "< 500 MB",
    "battery_consumption": "< 5% per hour",
    "storage_size": "< 2 GB"
}
```

**AI Agent –¥–ª—è Optimization:**
```
Analyze and optimize Android app performance:

Areas to optimize:
1. Database queries (add indexes, optimize schemas)
2. UI rendering (lazy loading, view recycling)
3. Network calls (caching, batching)
4. Memory management (leak detection, proper lifecycle)
5. Battery usage (background restrictions, wake locks)
6. APK size (ProGuard, resource optimization)

Tools to use:
- Android Profiler
- LeakCanary
- StrictMode
- Baseline Profiles

Provide:
- Performance analysis report
- Optimization recommendations
- Implementation of top 10 improvements
- Before/after metrics
```

---

## ü§ñ –†–æ–±–æ—Ç–∞ –∑ AI –ê–≥–µ–Ω—Ç–∞–º–∏ / Working with AI Agents

### –°—Ç—Ä–∞—Ç–µ–≥—ñ—è –í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è AI –ê–≥–µ–Ω—Ç—ñ–≤

### 1. –¢–∏–ø –ê–≥–µ–Ω—Ç—ñ–≤ —Ç–∞ —ó—Ö –†–æ–ª—ñ

#### A. Architecture Agent (Claude-3 Opus / GPT-4)
**–°–ø–µ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è:** –ü—Ä–æ–µ–∫—Ç—É–≤–∞–Ω–Ω—è –∞—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∏, —Ç–µ—Ö–Ω—ñ—á–Ω—ñ —Ä—ñ—à–µ–Ω–Ω—è
**–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è:** –°—Ç–∞—Ä—Ç–æ–≤–∞ —Ñ–∞–∑–∞, –∫—Ä–∏—Ç–∏—á–Ω—ñ —Ç–µ—Ö–Ω—ñ—á–Ω—ñ —Ä—ñ—à–µ–Ω–Ω—è

**–®–∞–±–ª–æ–Ω –ü—Ä–æ–º–ø—Ç—É:**
```
Role: Senior Software Architect specializing in automotive software

Context: Designing {component_name} for professional automotive diagnostic application

Requirements:
- {list_of_requirements}

Constraints:
- {list_of_constraints}

Expected output:
1. Architecture diagram (Mermaid)
2. Component descriptions
3. Interface definitions
4. Technology recommendations
5. Risk assessment

Format: Detailed technical specification document
```

#### B. Code Generation Agent (GitHub Copilot / Codex)
**–°–ø–µ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è:** –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è –∫–æ–¥—É, auto-completion
**–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è:** –©–æ–¥–µ–Ω–Ω–∞ —Ä–æ–∑—Ä–æ–±–∫–∞, boilerplate code

**–®–∞–±–ª–æ–Ω –¥–ª—è Copilot Chat:**
```
@workspace /new Generate {component_name} following these requirements:

1. Functionality: {describe_what_it_does}
2. Input: {describe_inputs}
3. Output: {describe_outputs}
4. Error handling: {error_scenarios}
5. Tests: {test_requirements}

Style guide: Follow Google Kotlin style guide
Documentation: Include KDoc comments
Performance: Optimize for mobile
```

#### C. Protocol Expert Agent (Specialized Model)
**–°–ø–µ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è:** Automotive protocols, ECU communication
**–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è:** –Ü–º–ø–ª–µ–º–µ–Ω—Ç–∞—Ü—ñ—è —Å–ø–µ—Ü–∏—Ñ—ñ—á–Ω–∏—Ö –ø—Ä–æ—Ç–æ–∫–æ–ª—ñ–≤

**–ü—Ä–∏–∫–ª–∞–¥ –ó–∞–ø–∏—Ç—É:**
```
Expert system prompt:

You are an automotive diagnostic protocol expert with 20 years of experience in:
- OBD-II standards
- CAN Bus protocols
- UDS (ISO 14229)
- KWP2000
- Manufacturer-specific protocols (VAG, BMW, etc.)

Task: Implement {protocol_name} for {vehicle_make}

Provide:
1. Protocol specification summary
2. Message structure
3. Complete implementation
4. Test cases
5. Known issues and workarounds

Reference: ISO standards, SAE J standards
```

#### D. Testing Agent (Test Generation AI)
**–°–ø–µ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è:** –ì–µ–Ω–µ—Ä–∞—Ü—ñ—è —Ç–µ—Å—Ç—ñ–≤, QA automation
**–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è:** Unit tests, integration tests, E2E tests

**–ü—Ä–æ–º–ø—Ç –¥–ª—è –ì–µ–Ω–µ—Ä–∞—Ü—ñ—ó –¢–µ—Å—Ç—ñ–≤:**
```
Generate comprehensive test suite for {class_name}:

Test types needed:
1. Unit tests (JUnit 5)
2. Integration tests
3. UI tests (Compose testing)
4. Edge cases
5. Error scenarios

Coverage target: > 85%
Mocking: Use MockK
Assertions: Use Truth library

For each test:
- Given/When/Then format
- Clear test names
- Proper setup/teardown
- Parameterized tests where applicable

Include performance and security tests
```

### 2. Workflow –∑ AI –ê–≥–µ–Ω—Ç–∞–º–∏

#### –©–æ–¥–µ–Ω–Ω–∏–π Workflow:

```mermaid
graph TD
    A[–í–∏–∑–Ω–∞—á–∏—Ç–∏ Task] --> B[–í–∏–±—Ä–∞—Ç–∏ AI Agent]
    B --> C[–ü—ñ–¥–≥–æ—Ç—É–≤–∞—Ç–∏ –ü—Ä–æ–º–ø—Ç]
    C --> D[–ó–≥–µ–Ω–µ—Ä—É–≤–∞—Ç–∏ –ö–æ–¥/–†—ñ—à–µ–Ω–Ω—è]
    D --> E[Code Review]
    E --> F{–Ø–∫—ñ—Å—Ç—å OK?}
    F -->|–ù—ñ| G[Refine –ü—Ä–æ–º–ø—Ç]
    G --> D
    F -->|–¢–∞–∫| H[–¢–µ—Å—Ç—É–≤–∞–Ω–Ω—è]
    H --> I[–Ü–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—è]
    I --> J[Commit]
```

#### –ü—Ä–∏–∫–ª–∞–¥ –°–µ—Å—ñ—ó –∑ AI Agent:

**Task: –Ü–º–ø–ª–µ–º–µ–Ω—Ç—É–≤–∞—Ç–∏ BMW Coding**

**–ö—Ä–æ–∫ 1: –î–æ—Å–ª—ñ–¥–∂–µ–Ω–Ω—è (Claude-3)**
```
Research prompt:

Analyze BMW coding system for F-series vehicles:
1. Coding methods (FSC, FDL, etc.)
2. Security and authentication
3. Data format and structure
4. Tools and protocols used
5. Common procedures

Output: Technical specification document
```

**–ö—Ä–æ–∫ 2: Design (GPT-4)**
```
Design prompt:

Based on the research, design BMW coding module:

Components:
- CodingManager class
- BMWAuthentication service
- FSCGenerator utility
- VINValidator

Patterns: Repository, Strategy, Factory
Dependencies: {list_dependencies}

Output: UML diagrams + interface definitions
```

**–ö—Ä–æ–∫ 3: Implementation (Copilot)**
```kotlin
// In IDE with Copilot
// Start typing with clear intent comments:

// BMW Coding Manager following BMW F-series specification
// Supports FSC codes, authentication, and validation
class BMWCodingManager {
    // Copilot will autocomplete...
}
```

**–ö—Ä–æ–∫ 4: Testing (Test Generation AI)**
```
Generate tests prompt:

Create test suite for BMWCodingManager covering:
1. Authentication success/failure
2. FSC code generation
3. VIN validation
4. Error handling
5. Mock BMW ECU responses

Framework: JUnit 5 + MockK
```

**–ö—Ä–æ–∫ 5: Documentation (GPT-4)**
```
Documentation prompt:

Generate user documentation for BMW coding feature:

Audience: Professional mechanics
Sections:
1. Overview
2. Prerequisites
3. Step-by-step procedure
4. Troubleshooting
5. Safety warnings
6. FAQ

Format: Markdown with screenshots
```

### 3. –®–∞–±–ª–æ–Ω–∏ –¥–ª—è –†—ñ–∑–Ω–∏—Ö –ó–∞–¥–∞—á

#### Template 1: Feature Implementation
```markdown
# Feature: {Feature Name}

## Context
- User story: {description}
- Acceptance criteria: {list}

## AI Agent Task

**Phase 1: Analysis**
Agent: {Agent Name}
Prompt: """
{detailed_requirements}
"""

**Phase 2: Design**
Agent: {Agent Name}
Prompt: """
{design_requirements}
"""

**Phase 3: Implementation**
Agent: {Agent Name}
Prompt: """
{implementation_requirements}
"""

**Phase 4: Testing**
Agent: {Agent Name}
Prompt: """
{testing_requirements}
"""

## Validation Checklist
- [ ] Meets acceptance criteria
- [ ] Code review passed
- [ ] Tests passing (coverage > 80%)
- [ ] Documentation updated
- [ ] Performance benchmarks met
```

#### Template 2: Bug Fix
```markdown
# Bug Fix: {Bug Description}

## Problem
- Symptom: {what_happens}
- Expected: {what_should_happen}
- Logs: {error_logs}

## AI Agent Task

**Step 1: Root Cause Analysis**
Agent: Debugging Agent
Prompt: """
Analyze the following error and identify root cause:

Code context: {relevant_code}
Error: {error_message}
Stack trace: {stack_trace}
Conditions: {reproduction_steps}

Provide:
1. Root cause explanation
2. Affected components
3. Fix recommendations
4. Prevention strategies
"""

**Step 2: Fix Implementation**
Agent: Code Generation Agent
Prompt: """
Implement fix for {bug_description}:

Root cause: {identified_cause}
Files to modify: {file_list}
Requirements: {fix_requirements}

Ensure:
- Backward compatibility
- No side effects
- Proper error handling
- Add regression test
"""

## Verification
- [ ] Bug reproduced
- [ ] Fix implemented
- [ ] Regression test added
- [ ] Manual testing passed
- [ ] Code reviewed
```

### 4. Best Practices –¥–ª—è AI-Assisted Development

#### ‚úÖ DO's:
1. **–ë—É–¥—å –ö–æ–Ω–∫—Ä–µ—Ç–Ω–∏–º** - –î–µ—Ç–∞–ª—ñ–∑–æ–≤–∞–Ω—ñ –ø—Ä–æ–º–ø—Ç–∏ –¥–∞—é—Ç—å –∫—Ä–∞—â—ñ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏
2. **–Ü—Ç–µ—Ä—É–π** - –ü–æ–ª—ñ–ø—à—É–π –ø—Ä–æ–º–ø—Ç–∏ –Ω–∞ –æ—Å–Ω–æ–≤—ñ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤
3. **–í–∞–ª—ñ–¥—É–π** - –ó–∞–≤–∂–¥–∏ –ø–µ—Ä–µ–≤—ñ—Ä—è–π –∑–≥–µ–Ω–µ—Ä–æ–≤–∞–Ω–∏–π –∫–æ–¥
4. **–î–æ–∫—É–º–µ–Ω—Ç—É–π** - –ó–±–µ—Ä—ñ–≥–∞–π —É—Å–ø—ñ—à–Ω—ñ –ø—Ä–æ–º–ø—Ç–∏ –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
5. **–¢–µ—Å—Ç—É–π** - AI –º–æ–∂–µ —Ä–æ–±–∏—Ç–∏ –ø–æ–º–∏–ª–∫–∏, —Ç–µ—Å—Ç–∏ –æ–±–æ–≤'—è–∑–∫–æ–≤—ñ
6. **–ù–∞–≤—á–∞–π—Å—è** - –†–æ–∑—É–º—ñ–π –∑–≥–µ–Ω–µ—Ä–æ–≤–∞–Ω–∏–π –∫–æ–¥, –Ω–µ –ø—Ä–æ—Å—Ç–æ –∫–æ–ø—ñ—é–π

#### ‚ùå DON'Ts:
1. **–ù–µ –î–æ–≤—ñ—Ä—è–π –°–ª—ñ–ø–æ** - AI –º–æ–∂–µ –≥–∞–ª—é—Ü–∏–Ω—É–≤–∞—Ç–∏ —Ñ–∞–∫—Ç–∏
2. **–ù–µ –Ü–≥–Ω–æ—Ä—É–π Security** - –ü–µ—Ä–µ–≤—ñ—Ä—è–π –Ω–∞ –≤—Ä–∞–∑–ª–∏–≤–æ—Å—Ç—ñ
3. **–ù–µ –ö–æ–ø—ñ—é–π –ë–µ–∑ –†–æ–∑—É–º—ñ–Ω–Ω—è** - –†–æ–∑—É–º—ñ–π –∫–æ–∂–µ–Ω —Ä—è–¥–æ–∫ –∫–æ–¥—É
4. **–ù–µ –ó–∞–±—É–≤–∞–π –ø—Ä–æ Edge Cases** - AI —á–∞—Å—Ç–æ –ø—Ä–æ–ø—É—Å–∫–∞—î –≥—Ä–∞–Ω–∏—á–Ω—ñ –≤–∏–ø–∞–¥–∫–∏
5. **–ù–µ –ù–µ—Ö—Ç—É–π Code Review** - –õ—é–¥—Å—å–∫–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∫—Ä–∏—Ç–∏—á–Ω–∞
6. **–ù–µ –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π –¥–ª—è –ö—Ä–∏—Ç–∏—á–Ω–∏—Ö –†—ñ—à–µ–Ω—å** - –§—ñ–Ω–∞–ª—å–Ω—ñ —Ä—ñ—à–µ–Ω–Ω—è - –∑–∞ –ª—é–¥–∏–Ω–æ—é

---

## üîß –Ü–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—è –ê–ø–∞—Ä–∞—Ç–Ω–æ–≥–æ –ó–∞–±–µ–∑–ø–µ—á–µ–Ω–Ω—è / Hardware Integration

### Hardware Requirements

#### –ú—ñ–Ω—ñ–º–∞–ª—å–Ω—ñ –í–∏–º–æ–≥–∏ –¥–æ –ü–ª–∞–Ω—à–µ—Ç—É:
```yaml
Android Tablet Specifications:
  OS: Android 11+ (API 30+)
  CPU: Octa-core 2.0 GHz+
  RAM: 4 GB minimum, 8 GB recommended
  Storage: 64 GB minimum
  Screen: 10" minimum, bright (500+ nits)
  Connectivity:
    - Bluetooth 5.0+
    - USB Type-C with OTG
    - WiFi 802.11ac
  Battery: 6000+ mAh
  Extras:
    - IP54 rating (dust/water resistant)
    - Rubberized case
    - Stylus support
```

#### –†–µ–∫–æ–º–µ–Ω–¥–æ–≤–∞–Ω—ñ –ü–ª–∞–Ω—à–µ—Ç–∏:
1. Samsung Galaxy Tab Active4 Pro (rugged, professional)
2. Lenovo Tab P11 Pro (good performance/price)
3. Huawei MatePad 11 (good hardware)

### Adapter Hardware Options

#### –û–ø—Ü—ñ—è 1: OBDLink MX+ (Ready-made)
```
Pros:
+ –ì–æ—Ç–æ–≤–∏–π –¥–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
+ –ù–∞–¥—ñ–π–Ω–∏–π, –ø–µ—Ä–µ–≤—ñ—Ä–µ–Ω–∏–π
+ –•–æ—Ä–æ—à–∞ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü—ñ—è
+ Multi-protocol –ø—ñ–¥—Ç—Ä–∏–º–∫–∞

Cons:
- –í–∞—Ä—Ç—ñ—Å—Ç—å ($100+)
- –û–±–º–µ–∂–µ–Ω—ñ –º–æ–∂–ª–∏–≤–æ—Å—Ç—ñ –∫–∞—Å—Ç–æ–º—ñ–∑–∞—Ü—ñ—ó
- –ó–∞–ª–µ–∂–Ω—ñ—Å—Ç—å –≤—ñ–¥ –≤–∏—Ä–æ–±–Ω–∏–∫–∞

Integration:
- Bluetooth SPP –ø—Ä–æ—Ñ—ñ–ª—å
- AT –∫–æ–º–∞–Ω–¥–∏ —á–µ—Ä–µ–∑ —Å–µ—Ä—ñ–π–Ω–∏–π –ø–æ—Ä—Ç
```

#### –û–ø—Ü—ñ—è 2: Custom ESP32-based Adapter
**AI Agent –¥–ª—è –†–æ–∑—Ä–æ–±–∫–∏:**

```
Design custom diagnostic adapter:

Hardware:
- MCU: ESP32-WROVER-E (WiFi + BT)
- CAN: MCP2515 + MCP2551
- K-Line: L9637D
- J1850: J1850 transceiver
- Power: LM2596 buck converter
- USB: CH340G USB-UART

Features:
- Multi-protocol support
- Over-the-air updates
- Built-in logging
- LED indicators
- Low power mode

Firmware features:
- AT command compatibility
- WiFi AP mode for direct connection
- BLE for low-power scenarios
- DTC snapshot capture
- Buffered communication

Deliverables:
1. Schematic (KiCad)
2. PCB layout
3. BOM with DigiKey part numbers
4. Firmware (Arduino/ESP-IDF)
5. 3D printable enclosure
6. Assembly instructions
7. Cost analysis

Target cost: < $50 for components
```

**–ü—Ä–∏–∫–ª–∞–¥ Firmware (ESP32):**
```cpp
// esp32_obd_adapter.ino
#include <BluetoothSerial.h>
#include <WiFi.h>
#include <CAN.h>

BluetoothSerial SerialBT;

// CAN Bus Configuration
#define CAN_TX_PIN 5
#define CAN_RX_PIN 4
#define CAN_SPEED 500E3  // 500 kbps

// K-Line Configuration
#define KLINE_TX_PIN 17
#define KLINE_RX_PIN 16

// Protocol enum
enum OBDProtocol {
    AUTO_DETECT = 0,
    ISO9141 = 3,
    KWP2000 = 4,
    CAN_11B_500K = 6,
    CAN_29B_500K = 7
};

OBDProtocol currentProtocol = AUTO_DETECT;

void setup() {
    Serial.begin(115200);
    SerialBT.begin("AutoDiagPro_BT");
    
    // Initialize CAN
    CAN.setPins(CAN_RX_PIN, CAN_TX_PIN);
    if (!CAN.begin(CAN_SPEED)) {
        Serial.println("CAN init failed!");
    }
    
    Serial.println("AutoDiagPro Adapter Ready");
}

void loop() {
    // Handle Bluetooth commands
    if (SerialBT.available()) {
        String command = SerialBT.readStringUntil('\r');
        handleCommand(command);
    }
    
    // Handle CAN messages
    if (CAN.parsePacket()) {
        handleCANMessage();
    }
}

void handleCommand(String cmd) {
    cmd.trim();
    
    if (cmd.startsWith("AT")) {
        handleATCommand(cmd);
    } else {
        handleOBDCommand(cmd);
    }
}

void handleATCommand(String cmd) {
    if (cmd == "ATZ") {
        // Reset adapter
        SerialBT.println("ELM327 v2.2 Compatible");
    } else if (cmd == "ATSP0") {
        // Auto protocol
        currentProtocol = AUTO_DETECT;
        SerialBT.println("OK");
    } else if (cmd.startsWith("ATSP")) {
        // Set protocol
        int protocol = cmd.substring(4).toInt();
        currentProtocol = (OBDProtocol)protocol;
        SerialBT.println("OK");
    } else if (cmd == "ATE0") {
        // Echo off
        SerialBT.println("OK");
    } else {
        SerialBT.println("?");
    }
    
    SerialBT.print(">");
}

void handleOBDCommand(String cmd) {
    // Parse OBD command (e.g., "01 00", "03")
    String response = "";
    
    if (currentProtocol == CAN_11B_500K || currentProtocol == CAN_29B_500K) {
        response = sendCANQuery(cmd);
    } else if (currentProtocol == ISO9141 || currentProtocol == KWP2000) {
        response = sendKLineQuery(cmd);
    }
    
    SerialBT.println(response);
    SerialBT.print(">");
}

String sendCANQuery(String cmd) {
    // Convert command to CAN frame
    // Send and wait for response
    // Parse response
    // Return formatted string
    
    // Example for PID 01 00
    if (cmd == "0100") {
        // Mock response - in real implementation, send/receive via CAN
        return "41 00 BE 3E B8 11";
    }
    
    return "NO DATA";
}

String sendKLineQuery(String cmd) {
    // Implement K-Line communication
    // ISO 9141-2 or KWP2000 protocol
    return "NO DATA";
}

void handleCANMessage() {
    int packetId = CAN.packetId();
    int packetLength = CAN.packetDlc();
    
    // Process incoming CAN messages
    uint8_t data[8];
    for (int i = 0; i < packetLength; i++) {
        data[i] = CAN.read();
    }
    
    // Forward to app if needed
}
```

### Android App - Hardware Communication

```kotlin
// hardware/bluetooth/BluetoothManager.kt
class BluetoothManager @Inject constructor(
    private val context: Context
) {
    private val bluetoothAdapter: BluetoothAdapter? = BluetoothAdapter.getDefaultAdapter()
    private var bluetoothSocket: BluetoothSocket? = null
    private var inputStream: InputStream? = null
    private var outputStream: OutputStream? = null
    
    suspend fun connect(deviceAddress: String): Result<Boolean> = withContext(Dispatchers.IO) {
        try {
            val device = bluetoothAdapter?.getRemoteDevice(deviceAddress)
            val uuid = UUID.fromString("00001101-0000-1000-8000-00805F9B34FB") // SPP UUID
            
            bluetoothSocket = device?.createRfcommSocketToServiceRecord(uuid)
            bluetoothSocket?.connect()
            
            inputStream = bluetoothSocket?.inputStream
            outputStream = bluetoothSocket?.outputStream
            
            Result.success(true)
        } catch (e: IOException) {
            Result.failure(e)
        }
    }
    
    suspend fun sendCommand(command: String): Result<String> = withContext(Dispatchers.IO) {
        try {
            outputStream?.write("$command\r".toByteArray())
            outputStream?.flush()
            
            val response = readResponse()
            Result.success(response)
        } catch (e: IOException) {
            Result.failure(e)
        }
    }
    
    private fun readResponse(timeoutMs: Long = 5000): String {
        val buffer = ByteArray(1024)
        val response = StringBuilder()
        val startTime = System.currentTimeMillis()
        
        while (System.currentTimeMillis() - startTime < timeoutMs) {
            if (inputStream?.available() ?: 0 > 0) {
                val bytesRead = inputStream?.read(buffer) ?: 0
                val data = String(buffer, 0, bytesRead)
                response.append(data)
                
                if (data.contains(">")) {
                    break
                }
            }
            Thread.sleep(10)
        }
        
        return response.toString().trim()
    }
    
    fun disconnect() {
        try {
            inputStream?.close()
            outputStream?.close()
            bluetoothSocket?.close()
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }
}

// Usage in ViewModel
class DiagnosticsViewModel @Inject constructor(
    private val bluetoothManager: BluetoothManager,
    private val obdRepository: OBDRepository
) : ViewModel() {
    
    private val _connectionState = MutableStateFlow<ConnectionState>(ConnectionState.Disconnected)
    val connectionState: StateFlow<ConnectionState> = _connectionState.asStateFlow()
    
    fun connectToAdapter(deviceAddress: String) {
        viewModelScope.launch {
            _connectionState.value = ConnectionState.Connecting
            
            val result = bluetoothManager.connect(deviceAddress)
            result.onSuccess {
                _connectionState.value = ConnectionState.Connected
                initializeConnection()
            }.onFailure {
                _connectionState.value = ConnectionState.Error(it.message ?: "Connection failed")
            }
        }
    }
    
    private suspend fun initializeConnection() {
        // Reset adapter
        bluetoothManager.sendCommand("ATZ")
        delay(1000)
        
        // Configure adapter
        bluetoothManager.sendCommand("ATE0")
        bluetoothManager.sendCommand("ATSP0")
        
        // Verify connection
        val result = bluetoothManager.sendCommand("0100")
        if (result.isSuccess) {
            Log.d("Diagnostics", "Adapter ready: ${result.getOrNull()}")
        }
    }
}
```

---

## üß™ –¢–µ—Å—Ç—É–≤–∞–Ω–Ω—è —Ç–∞ –ö–æ–Ω—Ç—Ä–æ–ª—å –Ø–∫–æ—Å—Ç—ñ / Testing and Quality Control

### –°—Ç—Ä–∞—Ç–µ–≥—ñ—è –¢–µ—Å—Ç—É–≤–∞–Ω–Ω—è

#### 1. Unit Testing (85%+ coverage)

**AI Agent –¥–ª—è –ì–µ–Ω–µ—Ä–∞—Ü—ñ—ó –¢–µ—Å—Ç—ñ–≤:**
```
Generate comprehensive unit tests for {ClassName}:

Framework: JUnit 5 + MockK
Style: Given-When-Then
Coverage target: > 85%

For each public method:
1. Happy path test
2. Edge cases (null, empty, boundary values)
3. Error scenarios
4. Performance tests (if applicable)

Include:
- Parameterized tests for multiple inputs
- Proper mocking of dependencies
- Assertion messages
- Test data builders

Example:
```kotlin
class OBDRepositoryTest {
    @Test
    fun `readDTCs should return list of DTCs when connection is successful`() {
        // Given
        val mockConnection = mockk<OBDConnection>()
        every { mockConnection.sendCommand("03") } returns "43 01 P0420 P0171"
        val repository = OBDRepository(mockConnection)
        
        // When
        val result = runBlocking { repository.readDTCs() }
        
        // Then
        assertThat(result.isSuccess).isTrue()
        assertThat(result.getOrNull()).hasSize(2)
        assertThat(result.getOrNull()?.first()?.code).isEqualTo("P0420")
    }
}
```
```

#### 2. Integration Testing

**–¢–µ—Å—Ç–∏ –Ü–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—ó –∑ Hardware:**
```kotlin
@RunWith(AndroidJUnit4::class)
class HardwareIntegrationTest {
    
    @Before
    fun setup() {
        // Requires real hardware adapter connected
        assumeTrue("Hardware adapter not found", isAdapterConnected())
    }
    
    @Test
    fun testFullDiagnosticsCycle() = runTest {
        // Connect
        val connected = connectToAdapter()
        assertThat(connected).isTrue()
        
        // Read DTCs
        val dtcs = readDTCs()
        assertThat(dtcs).isNotNull()
        
        // Read live data
        val liveData = readPID(PID.ENGINE_RPM)
        assertThat(liveData).isGreaterThan(0)
        
        // Disconnect
        disconnect()
    }
}
```

#### 3. UI Testing (Jetpack Compose)

```kotlin
@OptIn(ExperimentalTestApi::class)
class DashboardScreenTest {
    
    @get:Rule
    val composeTestRule = createAndroidComposeRule<MainActivity>()
    
    @Test
    fun dashboardDisplaysLiveData() {
        composeTestRule.setContent {
            DashboardScreen(
                viewModel = FakeDashboardViewModel()
            )
        }
        
        // Verify RPM gauge is displayed
        composeTestRule
            .onNodeWithText("RPM")
            .assertIsDisplayed()
        
        // Verify values update
        composeTestRule
            .onNodeWithText("2500")
            .assertIsDisplayed()
    }
}
```

#### 4. Performance Testing

```kotlin
class PerformanceTest {
    
    @Test
    fun measureDatabaseQueryPerformance() {
        val benchmark = measureTimeMillis {
            repeat(1000) {
                database.dtcDao().searchByCode("P0%")
            }
        }
        
        assertThat(benchmark / 1000).isLessThan(100) // < 100ms average
    }
    
    @Test
    fun measureUIRenderingPerformance() {
        // Use Android Benchmark library
        // Measure frame rendering time
        // Assert < 16ms per frame (60 FPS)
    }
}
```

### Quality Gates

```yaml
Quality Requirements:
  Code Coverage:
    Unit Tests: ">= 85%"
    Integration Tests: ">= 70%"
    Overall: ">= 80%"
  
  Code Quality:
    Complexity: "< 10 (cyclomatic)"
    Duplication: "< 5%"
    Code Smells: "0 critical"
    Vulnerabilities: "0"
    
  Performance:
    App Launch: "< 2s"
    Memory: "< 500MB"
    Battery: "< 5% per hour"
    APK Size: "< 150MB"
    
  Accessibility:
    WCAG Level: "AA"
    Touch Targets: ">= 48dp"
    Contrast Ratio: ">= 4.5:1"
```

### Continuous Integration Pipeline

```yaml
# .github/workflows/ci.yml
name: CI Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

jobs:
  build:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'
          
      - name: Build with Gradle
        run: ./gradlew build
        
      - name: Run Unit Tests
        run: ./gradlew test
        
      - name: Run Lint
        run: ./gradlew lint
        
      - name: Code Coverage
        run: ./gradlew jacocoTestReport
        
      - name: Upload Coverage to Codecov
        uses: codecov/codecov-action@v3
        
      - name: Static Analysis
        run: ./gradlew detekt
        
      - name: Security Scan
        run: ./gradlew dependencyCheckAnalyze

  ui-test:
    runs-on: macos-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Run Instrumented Tests
        uses: reactivecircus/android-emulator-runner@v2
        with:
          api-level: 33
          script: ./gradlew connectedCheck
```

---

## üîÑ –°–∏—Å—Ç–µ–º–∞ –û–Ω–æ–≤–ª–µ–Ω—å / Update System

### Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Android App    ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  Update Server   ‚îÇ
‚îÇ                 ‚îÇ  HTTPS  ‚îÇ  (FastAPI)       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ                           ‚îÇ
         ‚îÇ                           ‚îÇ
         ‚ñº                           ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Local Database ‚îÇ         ‚îÇ  CDN Storage     ‚îÇ
‚îÇ  (SQLite)       ‚îÇ         ‚îÇ  (AWS S3)        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Update Types

1. **App Updates** - –ß–µ—Ä–µ–∑ Google Play –∞–±–æ APK
2. **Data Updates** - DTCs, PIDs, Procedures
3. **Vehicle Updates** - –ù–æ–≤—ñ –º–æ–¥–µ–ª—ñ, –ø—Ä–æ—Ç–æ–∫–æ–ª–∏
4. **Firmware Updates** - –î–ª—è hardware adapter

### Implementation

```python
# backend/api/updates.py
from fastapi import FastAPI, HTTPException, Depends
from pydantic import BaseModel
from typing import List, Optional
import hashlib

app = FastAPI()

class UpdatePackage(BaseModel):
    id: str
    type: str  # "dtc", "vehicle", "procedure", "firmware"
    version: str
    size: int
    checksum: str
    url: str
    release_date: str
    mandatory: bool
    description: str

class UpdateRequest(BaseModel):
    app_version: str
    data_version: str
    vehicle_databases: List[str]
    device_id: str

@app.post("/api/v1/updates/check")
async def check_updates(request: UpdateRequest) -> List[UpdatePackage]:
    """
    Check for available updates
    """
    available_updates = []
    
    # Check data updates
    if is_data_update_available(request.data_version):
        update = get_data_update(request.data_version)
        available_updates.append(update)
    
    # Check vehicle database updates
    for vehicle_db in request.vehicle_databases:
        if is_vehicle_update_available(vehicle_db):
            update = get_vehicle_update(vehicle_db)
            available_updates.append(update)
    
    return available_updates

@app.get("/api/v1/updates/download/{update_id}")
async def download_update(update_id: str):
    """
    Get signed URL for update download
    """
    update = get_update_by_id(update_id)
    if not update:
        raise HTTPException(status_code=404, detail="Update not found")
    
    # Generate temporary signed URL (S3 presigned URL)
    signed_url = generate_signed_url(update.file_path, expires_in=3600)
    
    return {"url": signed_url, "checksum": update.checksum}

@app.post("/api/v1/updates/verify")
async def verify_update(update_id: str, checksum: str):
    """
    Verify downloaded update integrity
    """
    update = get_update_by_id(update_id)
    return {"valid": update.checksum == checksum}
```

```kotlin
// data/repository/UpdateRepository.kt
class UpdateRepository @Inject constructor(
    private val updateApi: UpdateApi,
    private val downloadManager: DownloadManager,
    private val database: AppDatabase
) {
    
    suspend fun checkForUpdates(): Result<List<UpdatePackage>> {
        val request = UpdateRequest(
            appVersion = BuildConfig.VERSION_NAME,
            dataVersion = getDataVersion(),
            vehicleDatabases = getInstalledVehicleDBs(),
            deviceId = getDeviceId()
        )
        
        return try {
            val updates = updateApi.checkUpdates(request)
            Result.success(updates)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    suspend fun downloadUpdate(update: UpdatePackage): Flow<DownloadProgress> = flow {
        // Get download URL
        val urlResponse = updateApi.getDownloadUrl(update.id)
        
        // Download with progress
        val file = downloadManager.downloadFile(
            url = urlResponse.url,
            destinationDir = getUpdateDirectory()
        )
        
        file.collect { progress ->
            emit(progress)
        }
        
        // Verify checksum
        val downloadedChecksum = calculateChecksum(progress.file)
        if (downloadedChecksum != update.checksum) {
            throw SecurityException("Checksum verification failed")
        }
        
        emit(DownloadProgress.Completed(progress.file))
    }
    
    suspend fun installUpdate(update: UpdatePackage, file: File): Result<Boolean> {
        return try {
            when (update.type) {
                "dtc" -> installDTCUpdate(file)
                "vehicle" -> installVehicleUpdate(file)
                "procedure" -> installProcedureUpdate(file)
                "firmware" -> installFirmwareUpdate(file)
                else -> throw IllegalArgumentException("Unknown update type")
            }
            
            // Update version in database
            updateDataVersion(update.type, update.version)
            
            Result.success(true)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    private suspend fun installDTCUpdate(file: File) {
        // Parse update file (JSON/SQLite)
        val dtcs = parseDTCUpdate(file)
        
        // Update database in transaction
        database.withTransaction {
            database.dtcDao().deleteAll()
            database.dtcDao().insertAll(dtcs)
        }
    }
}
```

### Update UI

```kotlin
@Composable
fun UpdatesScreen(
    viewModel: UpdatesViewModel = hiltViewModel()
) {
    val updates by viewModel.availableUpdates.collectAsState()
    val downloadProgress by viewModel.downloadProgress.collectAsState()
    
    Scaffold(
        topBar = {
            TopAppBar(title = { Text("Updates") })
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .padding(padding)
                .fillMaxSize()
        ) {
            Button(
                onClick = { viewModel.checkForUpdates() },
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(16.dp)
            ) {
                Text("Check for Updates")
            }
            
            LazyColumn {
                items(updates) { update ->
                    UpdateCard(
                        update = update,
                        progress = downloadProgress[update.id],
                        onDownload = { viewModel.downloadUpdate(update) },
                        onInstall = { viewModel.installUpdate(update) }
                    )
                }
            }
        }
    }
}

@Composable
fun UpdateCard(
    update: UpdatePackage,
    progress: DownloadProgress?,
    onDownload: () -> Unit,
    onInstall: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(horizontal = 16.dp, vertical = 8.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(
                    text = update.description,
                    style = MaterialTheme.typography.titleMedium
                )
                if (update.mandatory) {
                    Badge { Text("Required") }
                }
            }
            
            Spacer(modifier = Modifier.height(8.dp))
            
            Text(
                text = "Version: ${update.version}",
                style = MaterialTheme.typography.bodyMedium
            )
            
            Text(
                text = "Size: ${formatSize(update.size)}",
                style = MaterialTheme.typography.bodySmall
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            when (progress) {
                null -> {
                    Button(
                        onClick = onDownload,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Text("Download")
                    }
                }
                is DownloadProgress.Downloading -> {
                    LinearProgressIndicator(
                        progress = progress.percent / 100f,
                        modifier = Modifier.fillMaxWidth()
                    )
                    Text("${progress.percent}%")
                }
                is DownloadProgress.Completed -> {
                    Button(
                        onClick = onInstall,
                        modifier = Modifier.fillMaxWidth()
                    ) {
                        Text("Install")
                    }
                }
            }
        }
    }
}
```

---

## üíº –ë—ñ–∑–Ω–µ—Å-–ú–æ–¥–µ–ª—å / Business Model

### –°—Ç—Ä–∞—Ç–µ–≥—ñ—ó –ú–æ–Ω–µ—Ç–∏–∑–∞—Ü—ñ—ó

#### 1. Freemium Model

**Free Version:**
- ‚úÖ Basic DTC reading/clearing
- ‚úÖ Live data (10 PIDs)
- ‚úÖ 5 popular brands
- ‚úÖ Community support
- ‚ùå Advanced functions
- ‚ùå Pro vehicle coverage
- ‚ùå AI diagnostics

**Pro Version (‚Ç¨99/year or ‚Ç¨299 lifetime):**
- ‚úÖ All features unlocked
- ‚úÖ 50+ vehicle brands
- ‚úÖ Coding & programming
- ‚úÖ AI-powered diagnostics
- ‚úÖ Priority support
- ‚úÖ Unlimited updates
- ‚úÖ Cloud backup

#### 2. Vehicle Brand Packs (‚Ç¨29-‚Ç¨49 each)

- **European Pack** (VW, Audi, BMW, Mercedes, Opel, etc.)
- **Asian Pack** (Toyota, Honda, Nissan, Hyundai, etc.)
- **American Pack** (Ford, GM, Chrysler, Tesla, etc.)
- **Premium Pack** (Porsche, Jaguar, Land Rover, etc.)

#### 3. B2B Licensing

**Auto Repair Shops:**
- Multi-device license
- Centralized fleet management
- Custom branding
- Priority support
- Pricing: ‚Ç¨499-‚Ç¨999/year

**Professional Mechanics:**
- Single device
- All features
- Pricing: ‚Ç¨199/year

#### 4. Hardware Sales

**AutoDiagPro Adapter:**
- Cost: ‚Ç¨50-‚Ç¨80
- Profit margin: 40-50%
- Bundle with software subscription

### Market Analysis

```
Target Market:
‚îú‚îÄ‚îÄ DIY Enthusiasts: 1,000,000+ (Europe)
‚îú‚îÄ‚îÄ Small Repair Shops: 200,000+ (Europe)
‚îú‚îÄ‚îÄ Mobile Mechanics: 50,000+ (Europe)
‚îî‚îÄ‚îÄ Car Dealerships: 20,000+ (Europe)

Pricing Comparison:
- Launch X431 PRO: ‚Ç¨2,000-‚Ç¨3,000 + ‚Ç¨800/year updates
- Autel MaxiSys: ‚Ç¨3,000-‚Ç¨4,000 + ‚Ç¨1,000/year updates
- AutoDiagPro: ‚Ç¨299 lifetime or ‚Ç¨99/year ‚úì

Competitive Advantage:
1. Lower price (10x cheaper)
2. Modern interface
3. AI-powered diagnostics
4. Independent updates
5. Open platform
6. Community-driven
```

### Marketing Strategy

#### Online Presence:
1. **Website** - autodiagpro.com
2. **YouTube** - Tutorials, reviews, demos
3. **Facebook/Instagram** - Community, tips
4. **Forums** - Active participation
5. **Blog** - Technical articles, guides

#### Content Marketing:
- Video tutorials on YouTube
- How-to guides and blog posts
- Free diagnostic tips
- Vehicle-specific guides
- Comparison reviews

#### Partnerships:
- Auto parts retailers
- Online marketplaces (eBay, Amazon)
- Auto repair schools
- Automotive YouTubers
- Car clubs and communities

### Revenue Projections

```
Year 1:
- Users: 1,000 (conservative)
- Revenue: ‚Ç¨50,000
  - Software: ‚Ç¨30,000 (300 pro @ ‚Ç¨100)
  - Hardware: ‚Ç¨20,000 (400 units @ ‚Ç¨50 profit)

Year 2:
- Users: 5,000
- Revenue: ‚Ç¨250,000
  - Software: ‚Ç¨150,000 (1,500 pro @ ‚Ç¨100)
  - Hardware: ‚Ç¨100,000 (2,000 units @ ‚Ç¨50 profit)

Year 3:
- Users: 20,000
- Revenue: ‚Ç¨1,000,000
  - Software: ‚Ç¨600,000 (6,000 pro @ ‚Ç¨100)
  - Hardware: ‚Ç¨400,000 (8,000 units @ ‚Ç¨50 profit)
```

---

## üìö –†–µ—Å—É—Ä—Å–∏ —Ç–∞ –î–æ–≤—ñ–¥–Ω–∏–∫–∏ / Resources and References

### Documentation

#### Automotive Standards:
1. **SAE J1979** - E/E Diagnostic Test Modes
2. **ISO 15031** - OBD-II Communication
3. **ISO 14229** - UDS Protocol
4. **ISO 15765** - CAN Protocol
5. **SAE J2534** - PassThru Interface

#### Manufacturer Resources:
- **VW/Audi SSP** (Self Study Programs)
- **BMW TIS** (Technical Information System)
- **Mercedes WIS** (Workshop Information System)
- **Toyota TIS** (Technical Information System)

### Tools and Libraries

#### Android Development:
```gradle
// Essential libraries
androidx.compose:compose-bom:2023.10.01
androidx.navigation:navigation-compose:2.7.5
androidx.hilt:hilt-navigation-compose:1.1.0
androidx.room:room-ktx:2.6.0
com.squareup.retrofit2:retrofit:2.9.0
com.squareup.okhttp3:okhttp:4.12.0
io.coil-kt:coil-compose:2.5.0

// Testing
junit:junit:4.13.2
androidx.test.ext:junit:1.1.5
androidx.test.espresso:espresso-core:3.5.1
app.cash.turbine:turbine:1.0.0
io.mockk:mockk:1.13.8
com.google.truth:truth:1.1.5

// Code quality
io.gitlab.arturbosch.detekt:detekt-cli:1.23.3
org.jacoco:jacoco-maven-plugin:0.8.11
```

#### Python Backend:
```python
fastapi==0.104.1
uvicorn[standard]==0.24.0
sqlalchemy==2.0.23
pydantic==2.5.0
python-j1939==2.0.0
can==4.0.0
pytest==7.4.3
black==23.11.0
mypy==1.7.1
```

### Learning Resources

#### Courses:
1. **Android Development** - Udacity Android Nanodegree
2. **Jetpack Compose** - Google Developer Codelabs
3. **Automotive Protocols** - Udemy OBD-II Courses
4. **Kotlin** - JetBrains Academy

#### Books:
1. "Automotive Software Engineering" - Joerg Schaeuffele
2. "Vehicle Network Toolbox" - MathWorks
3. "Android Programming: The Big Nerd Ranch Guide"
4. "Kotlin in Action" - Dmitry Jemerov

#### Websites:
- **Stack Overflow** - Technical Q&A
- **GitHub** - Open source projects
- **Medium** - Technical articles
- **Reddit r/autodiag** - Community discussions

### Community and Support

#### Forums:
- Ross-Tech Forums (VAG)
- OBD-II Alley
- ELM327 Community
- XDA Developers

#### GitHub Repositories:
```
Useful open-source projects:
- python-OBD: Python OBD-II library
- freediag: Free diagnostics software
- PyOBD: Python OBD-II tool
- elm327-emulator: ELM327 simulator
```

---

## üéØ Roadmap —Ç–∞ Milestones

### Phase 1: MVP (Months 1-3)
- [x] Project setup
- [ ] Basic OBD-II implementation
- [ ] DTC read/clear functionality
- [ ] Live data monitoring
- [ ] 5 popular brands support
- [ ] Basic UI (Dashboard, Scanner, Live Data)
- [ ] Android app release (Alpha)

**Deliverable:** Working prototype with core features

### Phase 2: Enhancement (Months 4-6)
- [ ] Add 15 more vehicle brands
- [ ] Implement manufacturer protocols (VAG, BMW)
- [ ] Add special functions
- [ ] Improve UI/UX
- [ ] Add report generation
- [ ] Implement update system
- [ ] Beta testing with real users

**Deliverable:** Feature-complete app ready for beta

### Phase 3: Advanced Features (Months 7-9)
- [ ] AI-powered diagnostics
- [ ] Coding & programming
- [ ] Cloud sync
- [ ] Multi-language support (UA, EN, DE, FR, RU)
- [ ] Custom hardware adapter (optional)
- [ ] B2B features
- [ ] Google Play release

**Deliverable:** Production-ready application

### Phase 4: Growth (Months 10-12)
- [ ] Add 30+ more brands
- [ ] Advanced coding capabilities
- [ ] Mobile web version
- [ ] API for third-party integrations
- [ ] Enterprise features
- [ ] Marketing and user acquisition
- [ ] Partnership programs

**Deliverable:** Established product with growing user base

---

## üöÄ Getting Started - Quick Start Guide

### Step 1: Setup Development Environment

```bash
# Install Android Studio
# Download from: https://developer.android.com/studio

# Install Kotlin plugin (usually pre-installed)

# Clone starter template
git clone https://github.com/your-username/AutoDiagPro-Template
cd AutoDiagPro-Template

# Open in Android Studio
# File > Open > Select AutoDiagPro-Template folder
```

### Step 2: Create First Feature with AI Agent

**Task: Implement DTC Reader**

**Prompt for GitHub Copilot:**
```
Create DTC reader module:

Features:
1. Read diagnostic trouble codes via OBD-II
2. Parse response into DTC objects
3. Display in UI with descriptions
4. Clear codes functionality

Components:
- DTCRepository
- DTCViewModel
- DTCScreen (Compose)
- Unit tests

Follow MVVM architecture
Use Kotlin coroutines
Include error handling
```

### Step 3: Test on Virtual Device

```bash
# Create Android emulator
# Tools > Device Manager > Create Device

# Run app
# Run > Run 'app' or Shift+F10

# For hardware testing, enable USB debugging on tablet
```

### Step 4: Iterate with AI Agents

Follow the workflows and prompts provided in this guide to systematically build features.

---

## ‚úÖ Checklist –¥–ª—è –ó–∞–ø—É—Å–∫—É –ü—Ä–æ—î–∫—Ç—É

### Pre-Development:
- [ ] –í–∏–∑–Ω–∞—á–∏—Ç–∏ MVP features
- [ ] –í–∏–±—Ä–∞—Ç–∏ —Ç–µ—Ö–Ω–æ–ª–æ–≥—ñ—á–Ω–∏–π stack
- [ ] –°—Ç–≤–æ—Ä–∏—Ç–∏ —Ç–µ—Ö–Ω—ñ—á–Ω—É —Å–ø–µ—Ü–∏—Ñ—ñ–∫–∞—Ü—ñ—é
- [ ] –ü—ñ–¥–≥–æ—Ç—É–≤–∞—Ç–∏ –ø—Ä–æ–º–ø—Ç–∏ –¥–ª—è AI –∞–≥–µ–Ω—Ç—ñ–≤
- [ ] Setup Git repository
- [ ] Create project roadmap

### Development Phase:
- [ ] Setup Android Studio project
- [ ] Implement OBD-II communication
- [ ] Create database schema
- [ ] Develop UI screens
- [ ] Implement business logic
- [ ] Write tests (unit, integration, UI)
- [ ] Add error handling and logging
- [ ] Implement update system

### Testing Phase:
- [ ] Unit tests (85%+ coverage)
- [ ] Integration tests
- [ ] UI tests
- [ ] Hardware testing (multiple vehicles)
- [ ] Performance testing
- [ ] Security audit
- [ ] Beta testing with users

### Release Phase:
- [ ] Create Google Play listing
- [ ] Prepare marketing materials
- [ ] Setup backend infrastructure
- [ ] Create documentation
- [ ] Setup support system
- [ ] Launch marketing campaign
- [ ] Release to Google Play

### Post-Launch:
- [ ] Monitor crash reports
- [ ] Collect user feedback
- [ ] Plan updates
- [ ] Community building
- [ ] Partnerships development
- [ ] Continuous improvement

---

## ü§ù –ü—ñ–¥—Ç—Ä–∏–º–∫–∞ —Ç–∞ Community

### Support Channels:
- **Email:** support@autodiagpro.com
- **Forum:** community.autodiagpro.com
- **Discord:** discord.gg/autodiagpro
- **Telegram:** t.me/autodiagpro

### Contributing:
–ú–∏ –≤—ñ—Ç–∞—î–º–æ –≤–Ω–µ—Å–∫–∏ –≤—ñ–¥ community:
- Bug reports
- Feature requests
- Code contributions
- Documentation improvements
- Translations

### Open Source:
–†–æ–∑–≥–ª—è–Ω—å—Ç–µ –º–æ–∂–ª–∏–≤—ñ—Å—Ç—å open-source –ø–µ–≤–Ω–∏—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ñ–≤:
- Protocol libraries
- DTC database
- UI components
- Testing utilities

---

## üìû Contact

**Project Author:** [Your Name]
**Email:** your.email@example.com
**GitHub:** github.com/yourusername/AutoDiagPro
**Website:** autodiagpro.com

---

## üìÑ License

This guide is provided as-is for educational and development purposes.

```
MIT License

Copyright (c) 2024 AutoDiagPro

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

[Standard MIT License text]
```

---

## üôè Acknowledgments

Special thanks to:
- Open-source community
- AI agents (Claude, GPT-4, Copilot) for development assistance
- Automotive diagnostic standards organizations
- Beta testers and early adopters

---

## üìà –í–∏—Å–Ω–æ–≤–æ–∫ / Conclusion

–¶–µ–π –ø–ª–∞–Ω –Ω–∞–¥–∞—î –ø–æ–≤–Ω—É –¥–æ—Ä–æ–∂–Ω—é –∫–∞—Ä—Ç—É –¥–ª—è —Ä–æ–∑—Ä–æ–±–∫–∏ –ø—Ä–æ—Ñ–µ—Å—ñ–π–Ω–æ–≥–æ –∞–≤—Ç–æ–º–æ–±—ñ–ª—å–Ω–æ–≥–æ –¥—ñ–∞–≥–Ω–æ—Å—Ç–∏—á–Ω–æ–≥–æ –ü–ó –∑ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è–º AI-–∞–≥–µ–Ω—Ç—ñ–≤. –ö–ª—é—á–æ–≤—ñ –ø—Ä–∏–Ω—Ü–∏–ø–∏ —É—Å–ø—ñ—Ö—É:

1. **–ü–æ–µ—Ç–∞–ø–Ω–∏–π –ü—ñ–¥—Ö—ñ–¥** - –†–æ–∑–¥—ñ–ª–µ–Ω–Ω—è –Ω–∞ –∫–µ—Ä–æ–≤–∞–Ω—ñ —Ñ–∞–∑–∏
2. **AI-First** - –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è AI-–∞–≥–µ–Ω—Ç—ñ–≤
3. **–Ø–∫—ñ—Å—Ç—å** - –¢–µ—Å—Ç—É–≤–∞–Ω–Ω—è —Ç–∞ –∫–æ–Ω—Ç—Ä–æ–ª—å —è–∫–æ—Å—Ç—ñ –Ω–∞ –∫–æ–∂–Ω–æ–º—É –µ—Ç–∞–ø—ñ
4. **Community** - –ó–∞–ª—É—á–µ–Ω–Ω—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤ —Ç–∞ –∑–≤–æ—Ä–æ—Ç–Ω–∏–π –∑–≤'—è–∑–æ–∫
5. **–Ü—Ç–µ—Ä–∞—Ü—ñ—è** - –ü–æ—Å—Ç—ñ–π–Ω–µ –≤–¥–æ—Å–∫–æ–Ω–∞–ª–µ–Ω–Ω—è

**This comprehensive plan provides a complete roadmap for developing professional automotive diagnostic software using AI agents. Key success principles:**

1. **Phased Approach** - Breaking down into manageable phases
2. **AI-First** - Maximum utilization of AI agents
3. **Quality** - Testing and quality control at every stage
4. **Community** - User engagement and feedback
5. **Iteration** - Continuous improvement

–£–¥–∞—á—ñ —É –≤–∞—à–æ–º—É –ø—Ä–æ—î–∫—Ç—ñ! / Good luck with your project! üöóüíªü§ñ

---

*Last Updated: 2024*
*Version: 1.0*
*Language: Ukrainian / English*
